var express = require('express');
var router = express.Router();

var mongoose = require('mongoose');
mongoose.connect('mongodb://localhost/dmvc');
var db = mongoose.connection;
db.on('error', console.error.bind(console, 'connection error:'));
db.once('open', function() {
    // we're connected!
    console.log('DB connected');
});
/*var tasksSchema = mongoose.Schema({
    userID: String,
    task: String,
    done: Boolean
});
var taskModel = mongoose.model('Tasks', tasksSchema);*/



//  dMVC framework ------------------------
var _ = require('./lib/underscore');

var View = function (model) {

    this.modelID = model.id;

};

View.prototype = {

    setElement: function(el) {
        this.element = el;
    }

};

var Model = function (data) {

    _.extend(this, data);

};

Model.prototype = {

    save: function(req, res, next) {
        var self = this,
            task = new Controller._dbTask({
            userID: this.userID,
            task: this.task,
            done: this.done
        });
        task.save(function (err, task) {
            if (err) {
                res.json({error: err});
            } else {
                self.id = task._id;
                Controller.createView(self, req, res, next);
            }
        });
    }

};

var Controller = {

    getViews: function (req, res, next) {
        this._dbTask.find({userID: req.session.userID},function (err, tasks) {
            if (err) {
                res.json({error: err});
            } else {
                var models = _.map(tasks, function (obj) {
                    return new Model({
                        id: obj._id,
                        userID: obj.userID,
                        task: obj.task,
                        done: obj.done
                    });
                });
                res.json({models: models});
            }
            //console.log(kittens);
        })
    },

    addModel: function(req, res, next/*data*/) {
        var task = new Model({
            userID: req.session.userID,
            task: req.body.task,
            done: false
        });
        task.save(req, res, next);
    },

    removeModel: function(req, res, next) {
        Controller._dbTask.remove({_id: req.body.id}, function (err) {
            if (err) {
                res.json({error: err});
            } else {
                res.json({removed: true});
            }
        });
    },

    createView: function (model, req, res, next) {
        res.json({model: model});
    }

};

//  dMVC framework end ------------------------


//  app -----------------------------------

var init = function(dbConnection) {

    //Controller._db = dbConnection;  //mongoose

    //TODO: remove db reference into the model via some kind of config
    var tasksSchema = dbConnection.Schema({
        userID: String,
        task: String,
        done: Boolean
    });
    //var Task = mongoose.model('Tasks', tasksSchema);
    Controller._dbTask = dbConnection.model('Tasks', tasksSchema);

};

//Реализация наследования
(function() {
    var initializing = false,
        superPattern =  // Determine if functions can be serialized
            /xyz/.test(function() { xyz; }) ? /\b_super\b/ : /.*/;

    // Creates a new Class that inherits from this class
    Object.subClass = function(properties) {
        var _super = this.prototype;

        // Instantiate a base class (but only create the instance,
        // don't run the init constructor)
        initializing = true;
        var proto = new this();
        initializing = false;

        // Copy the properties over onto the new prototype
        for (var name in properties) {
            // Check if we're overwriting an existing function
            proto[name] = typeof properties[name] == "function" &&
            typeof _super[name] == "function" &&
            superPattern.test(properties[name]) ?
                (function(name, fn) {
                    return function() {
                        var tmp = this._super;

                        // Add a new ._super() method that is the same method
                        // but on the super-class
                        this._super = _super[name];

                        // The method only need to be bound temporarily, so we
                        // remove it when we're done executing
                        var ret = fn.apply(this, arguments);
                        this._super = tmp;

                        return ret;
                    };
                })(name, properties[name]) :
                properties[name];
        }

        // The dummy class constructor
        function Class() {
            // All construction is actually done in the init method
            if (!initializing && this.init) {
                this._preConstruct.apply(this, arguments);
                this.init.apply(this, arguments);
            }
        }

        // Populate our constructed prototype object
        Class.prototype = proto;

        // Enforce the constructor to be what we expect
        Class.constructor = Class;

        // And make this class extendable
        Class.subClass = arguments.callee;

        return Class;
    };
})();

var dMVC = {};

dMVC.Model = Object.subClass({

    _preConstruct: function(opt) {
        var tasksSchema = mongoose.Schema(this.schemaParameters);
        this._dbModel = mongoose.model(this.schemaName, tasksSchema);
    }

});

dMVC.TaskModel = dMVC.Model.subClass({

    schemaParameters: {
        userID: String,
        task: String,
        done: Boolean
    },
    schemaName: 'Tasks',

    initParameters: function(text, userID) {
        var task = new this._dbModel({
                userID: userID,
                task: text,
                done: false
            });
        task.save(function (err, task) {
            /*if (err) {
                res.json({error: err});
            } else {

            }*/
        });
        return task;
    }

});

dMVC.Controller = Object.subClass({

    _preConstruct: function(req) {
        if(this.model) {
            this.modelInstance = new dMVC[this.model]()
        }
    },

    init: function(req) {

    },

    processRequest: function(req, res, next) {
        var command = this[req.body.evtType](req);
    }

});

dMVC.AppController = dMVC.Controller.subClass({

    //TODO: автоматизировать - ответ на запрос посылать из processRequest, отсюда возвращать простой объект комманды
    createTask: function(req, res, next) {
        var taskController = new dMVC.TaskController();
        var task = taskController.newTask(req.body.text, req.session.userID);
        res.json({
            command: 'create',
            id: task._id,
            text: task.task,
            done: task.done
        });
    }

});

dMVC.TaskController = dMVC.Controller.subClass({

    model: 'TaskModel',

    newTask: function(text, userID) {
        return this.modelInstance.initParameters(text, userID);

    }

});

router.post('/', function(req, res, next) {

    var controller = new dMVC[req.body.emitter + 'Controller'](req);
    controller.processRequest(req, res, next);

    var text = req.body.data;
    if(req.body.evtType == 'createTask') {
        res.json({
            command: 'create',
            id: 1,
            text: text
        });
    } else if(req.body.evtType == 'deleteTask') {
        res.json({
            command: 'delete',
            id: req.body.emitter
        });
    }

});

module.exports = router;

/*
module.exports.init = init;
module.exports.Controller = Controller;*/
