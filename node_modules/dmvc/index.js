var _ = require('./lib/underscore');

var mongoose = require('mongoose');
//TODO: user db name
var dbConnection = mongoose.createConnection('mongodb://localhost/dmvc');


//Inheritance implementation (c)J.Resig
(function() {
    var initializing = false,
        superPattern =  // Determine if functions can be serialized
            /xyz/.test(function() { xyz; }) ? /\b_super\b/ : /.*/;

    // Creates a new Class that inherits from this class
    Object.subClass = function(properties) {
        var _super = this.prototype;

        // Instantiate a base class (but only create the instance,
        // don't run the init constructor)
        initializing = true;
        var proto = new this();
        initializing = false;

        // Copy the properties over onto the new prototype
        for (var name in properties) {
            // Check if we're overwriting an existing function
            proto[name] = typeof properties[name] == "function" &&
            typeof _super[name] == "function" &&
            superPattern.test(properties[name]) ?
                (function(name, fn) {
                    return function() {
                        var tmp = this._super;

                        // Add a new ._super() method that is the same method
                        // but on the super-class
                        this._super = _super[name];

                        // The method only need to be bound temporarily, so we
                        // remove it when we're done executing
                        var ret = fn.apply(this, arguments);
                        this._super = tmp;

                        return ret;
                    };
                })(name, properties[name]) :
                properties[name];
        }

        // The dummy class constructor
        function Class() {
            // All construction is actually done in the init method
            if (!initializing && this.init) {
                this._preConstruct.apply(this, arguments);
                this.init.apply(this, arguments);
            }
        }

        // Populate our constructed prototype object
        Class.prototype = proto;

        // Enforce the constructor to be what we expect
        Class.constructor = Class;

        // And make this class extendable
        Class.subClass = arguments.callee;

        return Class;
    };
})();

//Simple namespace
var dMVC = {};

dMVC.getController = function(req) {
    return new dMVC[req.body.emitter + 'Controller'](req);
};

//Simple Active Record
dMVC.Model = Object.subClass({

    init: function() {

    },

    getById: function(id, callback) {
        this._table.findOne({_id: id}, function (err, record) {
            if (err) {
                callback({error: err});
            } else {
                callback(record);
            }
        });
    },

    _preConstruct: function(opt) {
        try {
            this._table = dbConnection.model('Tasks');
        } catch (err) {
            var tasksSchema = mongoose.Schema({
                userID: String,
                task: String,
                done: Boolean
            });
            this._table = dbConnection.model('Tasks', tasksSchema);
        }
    },

    create: function(data) {
        return new this._table(data);

    }

});

dMVC.Controller = Object.subClass({

    _preConstruct: function(req) {

        if(this.model) {
            this.modelInstance = new dMVC[this.model]();
        }
        //console.log('dMVC.Controller._preConstruct: ', this.model, this.modelInstance);
    },

    init: function(req) {

    },

    processRequest: function(req, res, next) {
        var command = this[req.body.evtType](req, res, next);
    }

});

module.exports = dMVC;


